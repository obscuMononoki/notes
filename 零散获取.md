# 零散知识点 #

## js ##

+ 浮点数二进制在js中会无法精确

+ 对于用于定义并存储数组中某一个值的性质的变量,给与其中默认的一个值具备该性质会比较简单

+ 清除定时器和return的关系
    + return会停止函数并返回值,但是定时器依旧会继续执行,重新调用函数,注意函数是包含在定时器中的
    + 清除定时器则会将该定时器清除,但是函数中的代码依旧会继续向下执行,所以两者需要一起使用

+ 绑定的事件本身也是函数,可以直接作为函数调用,只是通常后再其中通过回调函数的形式调用其他函数,所以并没必要

+ 工作中function只会放在对象的原型中,不会放在对象中,所以通常在deepcopy对象的时候不会考虑是否有copy到函数.

+ 闭包:在一个作用域中可以访问另一个作用域的变量
+ 闭包可以在全局作用域中访问局部作用域的变量
+ 特点：延展了函数的作用域范围.
    + 闭包由函数结构决定,内部有调用了外部作用域的函数就会产生闭包.

+ 闭包在外面函数执行的时候就会进行语法判断,并因此产生闭包,就算不调用内部会调用外部变量的函数也会产生闭包.

+ 需要注意:闭包的内层函数必须作为外层函数的返回值才能在外部正确调用,内部函数调用的时候,调用者其实是window,this指向window,就算内部函数处在一个对象的方法内也是一样,除非外部函数将this赋值给变量并由内部函数调用.   

递归与闭包的区别:
+ 递归并没有调用上一级作用域中的变量,所以递归不会像闭包一样导致内存无法释放,且在变量执行完毕后会依次关闭释放内存.

+ typeof 只能判断基本数据类型和function
    + instanceof用于判断该对象是否在目标对象的原型链上

+ 递归的使用总是由一个已知的条件向另一个极限的条件进行挖掘,所以往往会形成由浅入深,由多向少,由一方向另一方.

+ 递归中只要具有可以导致函数不会执行更下一级的递归的条件就可以中断递归

```javascript
    arguments.callee() //实现递归
    // arguments记录了传入函数的实参
    // callee指针指向当前正在执行的函数
```

+ 函数在赋值的时候不能传入参数,只能在声明函数的时候为其设置虚参,而后可以在其他函数内进行回调的时候传入实参(通常会加入if判断以防没有传入)


问题
```javascript
// IIFE：immediately invoked functional expression 就是我们平常所说的立即执行函数：
(function() {

}());
//此两者区别在哪
;(function() {

})()
```
+ 可以利用或和与的短路运算的特性从而简化代码


## PHP

+ PHP中也具有预解析功能,但是与js中不同声明的变量在规范上最后进行赋值,否则会直接报错
    >Notice:  Undefined variable: y in D:\phpStudy\WWW\test\day1\index.php on line 39

+ PHP中用9大超全局数组变量,`$GLOBALS`就是其中之一
    + 全局变量其实可以认为是往超全局变量`$GLOBALS`中插入了元素
    + 同理在局部作用域中也是可以往超全局变量中添加元素,也可认为是往全局作用域中加入了对应的变量

+ $GLOBALS[index] 数组存所有的全局变量.

+ 与JS中不同,PHP中局部作用域和全局作用域中的变量是不能直接互相访问的,但是对于局部作用域可以通过 global 关键词在函数内引入对应的变量.
    > 注意: global是语句没有$,其作用只是在其他作用域引入全局作用域的变量

    > 注意: 事实上 `global $var;` 相当于在函数内部执行了 `$var = &$GLOBALS['var'];` 一个在函数内部作用域起效的别名引用,而 `$GLOBALS['var']`则是真是的指向了这个变量
    ```PHP
    echo "<br />";
    $aa = 99;
    function num() {
        global $aa; //该方法据说不推荐使用
        $GLOBALS['aa'] = 100;
        echo $aa;
        var_dump($GLOBALS['aa']);
    };
    echo "<br />";
    num();
    echo $aa;
    ```
+ 对于全局作用域 static 关键词,静态作用域,通常用于函数内部,且在声明变量的同时给变量赋值,进入静态作用域的变量不会因为函数执行结束就被释放掉,但其实也可以用于将函数内部的变量提取至静态作用域,且该变量不能被重新赋值,但其值依旧可以通过运算来改变,与js中的闭包不同是一个独立的作用域概念.
```php
static $x;
function myTest() {
    // global $x;
    $x=0;
  echo $x;
  $x++;
}

myTest();
$x = 10;
echo "<br />";
myTest();
echo "<br />";
myTest();
```

+ PHP中对注释除了/**/ // 还有首行#
+ 注意:变量前`$`并不是声明,而是对变量的标识.
+ PHP只对用户定义的类,函数以及语句的大小写不敏感.
    + 需要注意对函数名的大小写也不敏感,对于较长的函数名最好使用 _

+ `echo` 和 `print` 之间的差异:
    + `echo` - 能够输出一个以上的字符串
    + `print` - 只能输出一个字符串，并始终返回 1
    >注意：`echo` 比 `print` 稍快，因为它不返回任何值。在使用`echo`和`print`输出变量的时候,除非只用输出单个变量,否则变量也应该和字符串一起使用引号包裹.

+ `echo`在PHP中是作为语句存在,但其实也可以带括号`echo()`使用

+ `print_r()`与`vardump()`类似但是不能打印布尔值的原始类型,所输出信息较少;

+ `var_dump()`在输出的时候会从上一个文本输出的位置开始独占一行的剩余部分
+ `<pre></pre>`标签只对复杂类型的输出有排版效果
+ null在使用`echo`打印的时输出为空,而`var_dump`所输出的NULL其实是数据类型
```php
$txt1="Learn PHP";
$txt2="W3School.com.cn";
$cars=array("Volvo","BMW","SAAB");
echo $txt1;
echo "<br>";
echo "Study PHP at", $txt2;
echo "<br>";
print "Study PHP at $txt2";
echo "<br>";
echo "My car is a {$cars[0]}";
echo "<br>";
echo "My car is a $cars[0]";
```

+ `strlen`函数,类似于js中string的length方法
+ `strpos`函数,用于匹配字符串中的文本,返回第一个匹配的文本位置

+ `unset`事实上只会解除变量名和其值之间的对应关系,变量名和变量值都不会<strong>立即消失</strong>

+ 与HTML不同,PHP没有自动填充需要手动设置unicode字符集
    ```PHP
        header("content-type:text/html;charset=utf8");
        //返回数据的类型：text/html  将来使用html解析器解析
        //使用utf8字符集展示
    ```
+ `isset()`用于判断**变量**是否设置或为NULL,有输出true
+ `empty()`用于判断**变量**是否为**空**,一切无意义的情况都会判断为true,需要注意的是"0", []也会判断为空

+ 数据类型的强制转换
    + 事实上与数据的自动转换一致,相比JS中的强制转换更加直观
    + 强制转换并不会转换数据的原始类型,可以理解为返回的是转换后的值
    ```PHP
    (int/string/bool/float) $var
    ```
+ 常量
    + 常量与静态作用域中的变量不同,其值在脚本执行周期内不会改变,既不能修改,不能删除,不能重复定义
    + 常量名通常字母全大写
    + 不能再函数,流程控制语句中定义常量
    ```PHP
    // 定义常量
    define(常量名，常量值);
    const 常量名=常量值;
    // 判断常量是否有定义,返回true和false
    defined(‘常量名’);
    ```

+ 运算符依照所操作的数目(数值个数)可以分为一元,二元,三元
+ PHP中有专门的字符串拼接运算符`.`
    + 用于拼接不同的表达式,所拼接的表达式会被认为是一个表达式
    + PHP有专门的输出缓冲层（output buffer layer），只有缓冲区域的数据达到指定大小，才会输出。尽量使用字符串连接符，提升代码的执行效率。

+ 问题 运算符具有左或右结合性
+ 问题 引用和指针的区别

+ `die(), exit()`退出代码,括号内可输出字符串,状态值,可执行函数
    + `return`只是跳出当前函数
+ `sleep(seconds)`将进程挂起一段时间,成功返回0,反之返回false

+ PHP的预编译是将函数代码存放在内存的代码区这里和JS的预读取并不一样

+ PHP中的函数与JS不同,可以在形参位置直接设定默认值,没有为有默认值的参数传递参数,则使用默认值,默认值不可是变量,且应放于尽量靠后的参数位置
```PHP
// 问题 实参	调用时将数据传递给对应的形参。英文：argument。实参可以为具体的值，也可以为变量。要与形参的个数一致
// 问题NULL的大小写所代表意义的问题
// 问题
function demo_01 ($var = 333) {
    echo $var;
};
demo_01();
echo("<br />");
demo_01(222);
echo("<br />");
demo_01(undefined);
echo("<br />");
demo_01(NULL);
echo("<br />");
demo_01(null);
```
+ PHP 中的函数返回值,在没有设置return的情况下与JS不同默认返回NULL 问题 需确认
问题PHP中没有和JS类似的arguments属性吗
+ PHP中与js中数组是一个特殊的对象不同,数组和对象是两个概念

+ `time()``date()`,与JS不同,time所输出的时间戳为秒数,而`date()`则用于格式化时间戳,其第二个参数输出可选的,默认是当前时间的时间戳
+ `date_default_timezone_get()`和`date_default_timezone_set()`分别是获取当前服务器时区和设置当前服务器时区,在PHP.ini设置失效的时候可以直接在脚本内部进行设置
```PHP
// 获取当前时间戳
time();
// 用于将时间文本转回时间戳
strtotime(2016-3-18 6:6:6);
//获取默认时区  
date_default_timezone_get();  
//于脚本内设置默认时区
date_default_timezone_set("PRC");
// 输出格式化时间
date('Y-m-d H:i:s');  
```
+ PHP数学函数
    + `max()`,`min()`--分别返回一组数的最大值及最小值
    + `abs()`--返回绝对值。
    + `floor()`--向下取整。
    + `ceil()`--向上取整
    + `round()`--四舍五入。
    + `rand()` 和 `mt_rand()`--返回随机数，可以取到两端的值。mt_rand生成的速度比rand快四倍多。
+ `decbin()`用于将十进制数转化为二进制数


+ PHP中索引数组和关联数组的区别仅在下标是否有语义化即是否为字符串,与JS中不同,未规定数组索引的情况下索引数会默认从0开始,且只对未规定数组索引的元素起效,对数组中的元素顺序无影响





+ `rand()`和`mt_rand()`的取值范围在没有参数的情况下,会饭后0到RAND_MAX之间的伪随机数



### TODO

- [ ] ieee 754 单精度浮点数
- [ ] 表达式 匹配字符规则

匹配神经学特征码

安装github

整理前后端交互的md

~~指针的意思~~

<del>安装studyphp2018</del>

<s>用officetool安装word</s>



### 预备的可能有点用的函数
```PHP
// 输出格式化的复杂类型变量
function var_dump_pre($var) {
    echo "<pre>";
    var_dump($var);
    echo "</pre>";
}

header("content-type:text/html;charset=utf8");
```
前端语言的路径前的`/`是一个默认的网站根目录路径,而对于服务器后端语言而言,并没有一个默认的绝对路径


